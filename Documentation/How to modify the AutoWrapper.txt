
Written (after reverse-engineering) by Manski in 2010


AutoWrapper - overview
======================
This tool generates C++/CLI wrapper code from C++ header file (.h). It needs
the following input files to work:

 * "meta.xml" (in Mogre/Codegen/cpp2java/build) : generated by "cpp2java"; 
     contains the structure of all .h files in an XML format
 * "Attributes.xml" (in Mogre/Codegen/Attributes.xml) : contains information 
     about how to tweak the information in "meta.xml" (e.g. ignore classes, add 
     custom code, ...). See "readme-attributes.txt" for more information.

This tool is used to generate most of MOGRE's source code.

Usage: Simply start the program and click on the "Generate" button. This will
generate the C++/CLI sources.




Attributes.xml
==============
The file "Attributes.xml" specifies information about how to convert the native
OGRE sources to the CLR MOGRE sources. It is used by the "AutoWrap" application
to tweak the file "meta.xml" (generated by "cpp2java").

This file will provide some documentation for the "Attributes.xml" file.

As for the terminology: We need to differentiate between "native" (C/C++, source
source code) source code and CLR (C++/CLI + .NET, destination source code) 
source code. Therefore the former will be called "native" and the latter "CLR".


Attributes.xml in general: Adding attributes
--------------------------------------------
As said above this file is used to tweak the generation of the source files. 
This section will provide some examples on how to read/write this file.

The basic idea behind this file is to add XML attributes to elements of the
"meta.xml" file. Each element is identified by

  * its position in the XML tree, i.e. in which <namespace> the element is 
    contained in
  * the element type (e.g. "<class>", "<typedef>", "<variable>", ...)
  * the element's name (i.e. the name attribute)
  
Therefore a class in the "Ogre" namespace (note that its the native namespace, 
not the CLR namespace - if they have different names) named "ScriptToken" would
be identified by this XML code:

  <meta>
    <namespace name="Ogre">
      <class name="ScriptToken"/>
    </namespace>
  </meta>
  
To add attributes to this element, simply add them to the XML element. For 
example, to ignore the previously mentioned class, use this XML code:

  <meta>
    <namespace name="Ogre">
      <class name="ScriptToken" Ignore=""/>
    </namespace>
  </meta>
  
If the attribute requires a lot of information (such as a custom implementation),
it can alternatively be implemented as a so called "Attached Attribute". An
attached attribute is an XML element with the attribute name as tag name but
prefixed with an underscore (see example below). The attribute is "attached" to
the surrounding XML element (hence the name). For example, the following code
does the same as the previous code: ignoring the class "ScriptToken":

  <meta>
    <namespace name="Ogre">
      <class name="ScriptToken">
        <_Ignore/>
      </class>
    </namespace>
  </meta>
 
The text within the attached attribute (none was provided in the previous 
example) will be used as attribute value while the tag name (without the 
underscore) will obviously be used as attribute name.

Another example: To rename a member variable (e.g. "error") of a class (e.g. 
"BackgroundProcessResult"), use this XML code:

  <meta>
    <namespace name="Ogre">
      <class name="BackgroundProcessResult">
        <variable name="error" Rename="Error" />
      </class>
    </namespace>
  </meta>

Note also that you may specify an element multiple times. The changes to the
class/element will be merged:

  <meta>
    <namespace name="Ogre">
      <class name="MovableObject">
        <function name="isVisible" Method=""/>
      </class>
      ...
      <class name="MovableObject">
        <function name="setUserAny" Ignore="" />
        <function name="getUserAny" Ignore="" />
      </class>
    </namespace>
  </meta>


Adding custom code
------------------
Another major point is the ability to add custom code to the generated files. 
There are the following XML elements available for this:

 * <_CustomIncDeclaration> : Places the code in the .h file.
 * <_CustomCppDeclaration> : Places the code in the .cpp file.
 * <_CustomDisposing> : Adds code to the dispose method ("!ClassName()").
 
You can add this element either to <class>es/<struct>s or to <function>s. The
following XML code adds some C++/CLI code at the top of Texture's class 
definition (in the .h file):

  <meta>
    <namespace name="Ogre">
      <class name="Texture">
        <_CustomIncDeclaration>
    #ifdef LoadImage
      #undef LoadImage
    #endif
        </_CustomIncDeclaration>
      </class>
    </namespace>
  </meta>

NOTE: Be careful when adding code that contains templates/generics. The brackets
  will be interpreted by the XML parser if they aren't escaped (with &lt;/&gt;
  or the code with <![CDATA[ ... ]]>).
  
Note that the indention of the code snippet is copy directly to the source file;
this means that the indention in the Attributes.xml file might not match the
indention of the XML tags (as in the example above).

Besides simply adding code, the most important use of this feature is to replace
the code of some functions. There are basically two ways of doing this tough 
these ways have a subtle difference.

Option 1: replace the function's body (note that the name of the function has 
been changed in the C++/CLI code).

  <class name="Mesh">
    <function name="softwareVertexPoseBlend">
      <_CustomCppDeclaration>
      void Mesh::SoftwareVertexPoseBlend( Mogre::Real weight, Collections::Generic::SortedList&lt;size_t, Mogre::Vector3>^ vertexOffsetMap, Mogre::VertexData^ targetVertexData )
      {
          Ogre::map&lt;size_t,Ogre::Vector3>::type o_vertexOffsetMap;
          FillMapFromSortedList&lt;Ogre::map&lt;size_t,Ogre::Vector3>::type, size_t, Mogre::Vector3>(o_vertexOffsetMap, vertexOffsetMap);

          Ogre::Mesh::softwareVertexPoseBlend( weight, o_vertexOffsetMap, targetVertexData );
      }
      </_CustomCppDeclaration>
    </function>
  </class>

Option 2: Ignore the function and provide custom code for the surrounding class.

  <class name="DriverVersion" WrapType="ValueType" SequentialLayout="">
    <function name="toString" Ignore="" />
    <_CustomIncDeclaration>
      public:
        virtual System::String^ ToString() override {
          return System::String::Format("{0}.{1}.{2}.{3}", major, minor, release, build);
        }
    </_CustomIncDeclaration>
  </class>

As mentioned before there is a subtle difference between these two options. If
you ignore a function (like "toString" in the example before), its definition
will be removed from the .cpp and the .h file. Therefore when ignoring a 
function and creating custom declaration results in:

  * with <_CustomIncDeclaration>: Function is moved to the header file (but 
    remains visible
  * with <_CustomCppDeclaration>: Not possible (at least not together with a
    simple "Ignore") since you can't define a class function in a .cpp file when
    the function hasn't been declared in the .h file (usually).


Reference
---------
The following XML elements are available (under <namespace>):

  * <class> : denotes a "class"
  * <struct> : denotes a "struct"
  * <typedef> : ???
  * <variable> : denotes a classes'/struct's member variable
  * <function> : denotes a classes' method
  
TODO: See XML class documentation under "Meta\Attributes".

The following XML attributes can be added to the above mentioned XML elements:

  * "Ignore" - valid values: value ignored - valid elements: all
      If this attribute is found, the element (class, typedef, variable, ...)
      will be ignore, meaning that no code will be generated for it. (The value
      of the attribute is ignored as well. Even setting it to "false" still 
      results in the element to be ignored.)
      
  * "Rename" - valid values: identifier name - valid elements: all
      Renames the element, i.e. it'll have a different name in the generated
      sources than it had in the original sources.
      
  * "PureManagedClass" - valid values: member variable name or empty - valid elements: "class"
      Indicates that the class is completely replaced by a custom 
      implementation with the same name. If a value is provided for this 
      attribute, it denotes the name of the classes' member variable whose
      pointer represent the classes' data (i.e. this is usually the first member
      variable, like "m00" for a matrix).
      TODO: What happens when there is no name? What's the exact difference?
      
  * "WrapType" - valid values: see below - valid elements: "class", "struct"
      Sets how the class or the struct are to be wrapped. The following values
      are available (but only one can be used at a time):
      TODO: What happens without this attribute?
      * CLRHandle - valid for: "class"
          creates a wrapper for this class
          TODO: What's exactly the difference when not using "WrapType"?
      * Interface - valid for: "class"
          converts an abstract C++ class into a CLR interface. The class must
          not contain any implemented methods (except an empty destructor). The
          name is prefixed with an "I" (like "IMeshSerializerListener" for
          "MeshSerializerListener").
      * ValueType - valid for: "class", "struct"
          converts this class/struct to a "value class" (a C# struct).
      * NativePtrValueType - valid for: "class", "struct"
          creates a "pure" wrapper for this class or struct. "Pure" means that
          all calls to the generated class will be redirected to the underlying
          native type. Note that the generated class will be a "value class".
      * PlainWrapper - valid for: "class", "struct"
          the same as "NativePtrValueType" except that a "ref class" will be
          generated (instead of a "value class").
      * NativeDirector
          ???
      * ReadOnlyStruct - valid for: "class", "struct"
          generates a "ref class" which all member variables converted to 
          readonly CLR properties
      * NonOverridable
          ??? (used for enums)
  
  * ReadOnly - valid values: value ignored - valid elements: "class", "struct", "typedef"
      ??? (if not specified, allows creation of new elements)
  
  * SequentialLayout - valid values: value ignored - valid elements: "class", "struct"
      Adds the CLR attribute "[StructLayout(LayoutKind::Sequential)]" to the
      class. Note that the wrap type must be a "value class".
